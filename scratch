# def refactor_action_rows(action_rows, link_displacements):
#     def find_child_in_row(child_group, parent_group, link_row_index):
#         for link_index in range(0, len(link_displacements[link_row_index])):
#             link = link_displacements[link_row_index][link_index]
#             if (link["srcGroup"] == parent_group) and (link["destGroup"] == child_group):
#                 return [child_group, link["destRowIndex"], link["destActionIndex"]]
#         return [None, None, None]
#
#     def find_child(find_args):
#         [child_group, parent_group, parent_row_index] = find_args
#         [child_group, child_row_index, child_action_index] = find_child_in_row(child_group, parent_group, parent_row_index)
#         if child_row_index is None:
#             if parent_row_index - 1 >= 0:
#                 return find_child_in_row(child_group, parent_group, parent_row_index - 1)
#             else:
#                 return [None, None, None]
#         else:
#             return [child_group, child_row_index, child_action_index]
#
#     for action_row_index in range(0, len(action_rows)):
#         action_row = action_rows[action_row_index]
#         for action_index in range(0, len(action_row["actions"])):
#             action = action_row["actions"][action_index]
#             action_rows[action_row_index]["actions"][action_index]["childGroups"] = list(map(find_child, [[child_group, action["actionGroup"], action_row_index]
#                                                      for child_group in action["childGroups"]]))
#     return action_rows


        elif action["actionName"] == "connectToServer":
            if action["serverType"] == "adb":
                print('starting emulator')
                local = True

                def adb(adb_args):
                    return action["adbPath"] + adb_args

                emulator_process = subprocess.Popen([action["emulatorPath"], '-avd', action["deviceName"]],
                                                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                # exit(0)
                #
                print('completed startup')
                if not local:
                    emulator_ip = None
                    ip_search_string = '[0-9]*[.][0-9]*[.][0-9]*[.][0-9][:][0-9]*'
                    timeout_counter = 0
                    while True:
                        emulator_process_out = emulator_process.stdout.readline()
                        if emulator_process_out == '' and emulator_process.poll is not None:
                            break
                        elif emulator_ip is None:
                            print(emulator_process_out)
                            ip_match = re.search(ip_search_string, str(emulator_process_out))
                            if ip_match is not None:
                                emulator_ip = ip_match.group(0)
                                break
                        time.sleep(0.1)
                        timeout_counter += 0.1
                        if timeout_counter > 20:
                            print('emulator startup timed out')
                            return ['failure', action], state
                    if emulator_ip is None:
                        return ['failure', action]
                    print('search completed ', emulator_ip)
                    # Load the public and private keys

                    adbkey = action["adbKeyPath"]
                    if adbkey.split('.')[-1] == "pub":
                        adbkey = '.'.join(adbkey.split('.')[:-1])
                    with open(adbkey) as f:
                        priv = f.read()
                    with open(adbkey + '.pub') as f:
                        pub = f.read()
                    signer = PythonRSASigner(pub, priv)
                    print('key signed')
                    [emulator_ip, port] = emulator_ip.split(':')
                else:
                    pass
                ## issue adb connect command
                device_status_search_string = 'emulator-' + '[0-9]*' + '[ ]*offline'
                # Connect
                while True:
                    print('here')
                    devices_list = subprocess.run([action["adbPath"], "devices", "-l"], stdout=subprocess.PIPE)
                    print(devices_list.stdout)
                    if re.search(device_status_search_string, str(devices_list.stdout)) is None:
                        print('device loaded')
                        break
                    time.sleep(1)
                # remember to use sudo
                # Send a shell command
                print('connection succesful')
                return ['success', action], state



#----------------------------------





# def simulate_path(self, deviation_degree, deviation_chance, n_sims, plot=False):
#     plot_title = str(deviation_degree) + '-' + str(deviation_chance)
#     if plot:
#         print(plot_title)
#         plt.title(plot_title)
#         one_plot = (n_sims == 1)
#         if one_plot:
#             fig, ax = plt.figure(dpi=150), plt.gca()
#         else:
#             fig, ax = plt.subplots(n_sims, n_sims, dpi=150)
#     deltalists = []
#     for sim_row_index in range(0, n_sims):
#         deltalists.append([])
#         for sim_col_index in range(0, n_sims):
#             deltalists[sim_row_index].append([])
#             # with open('./figs/' + plot_title + '-logfile-' + str(sim_row_index) + '-' + str(sim_col_index) + '.txt', 'w') as log_file:
#             target_source_dist = 0
#             x_dist = 0
#             y_dist = 0
#             while target_source_dist < 0.4 or x_dist < 0.1 or y_dist < 0.1:
#                 source_point_x = random.random()
#                 source_point_y = random.random()
#
#                 target_point_x = random.random()
#                 target_point_y = random.random()
#                 x_dist = abs(source_point_x - target_point_x)
#                 y_dist = abs(source_point_y - target_point_y)
#                 target_source_dist = dist(source_point_x, source_point_y, target_point_x, target_point_y)
#
#             # log_file.write('source:\n')
#             # log_file.write('\t' + str(source_point_x) + ',' + str(source_point_y) + '\n')
#             # log_file.write('target:\n')
#             # log_file.write('\t' + str(target_point_x) + ',' + str(target_point_y) + '\n')
#             pointlist_x = [source_point_x]
#             pointlist_y = [source_point_y]
#             checkpoint_x = source_point_x
#             checkpoint_y = source_point_y
#             pathlist_x = [checkpoint_x]
#             pathlist_y = [checkpoint_y]
#             deltalist_x = []
#             deltalist_y = []
#
#             delta_x, delta_y = self.generate_delta_function(source_point_x, source_point_y, target_point_x,
#                                                             target_point_y)
#             # print([sign_x, sign_y])
#             # print([source_point_x, source_point_y])
#             # print([target_point_x, target_point_y])
#             # print([delta_x(0, 1/100), delta_y(0, 1/100)])
#             # print(180 * init_angle / math.pi)
#             if plot:
#                 if one_plot:
#                     ax.plot(source_point_x, source_point_y, "bo")
#                 else:
#                     ax[sim_row_index][sim_col_index].plot(source_point_x, source_point_y, "bo")
#             delta_delta_x = 0
#             delta_delta_y = 0
#             acc_delta_x = 0
#             acc_delta_y = 0
#             delta_delta_decay = 0
#             delta_x_threshold = 68.25 / 32726
#             delta_y_threshold = 121.5 / 32726
#             accelerated_path = 0.6
#             correction_chance = 1 / (1.6 - deviation_chance)
#             n_steps = 100
#             steps = 0
#             delta_speed = 0
#             markov_ratio = 0
#             last_source_point_x, last_source_point_y = source_point_x, source_point_y
#             init_speed = random.randint(1, 3) / 100
#             acceleration_time = random.randint(2, 6)
#             # log_file.write('points:\n')
#             sensitivity = target_source_dist / 100
#             while target_source_dist > 2 * dist(source_point_x, source_point_y, last_source_point_x,
#                                                 last_source_point_y):
#                 if accelerated_path > 0.5:
#                     delta_speed = markov_ratio * delta_speed * (1 + (np.random.normal() / 25)) + (1 - markov_ratio) * (
#                                 (-init_speed / (2 / init_speed) * steps + init_speed) * min(steps / acceleration_time,
#                                                                                             1))
#                 else:
#                     delta_speed = 1 / 100
#                 if random.random() < deviation_chance:
#                     deviation_seed = 100
#                     while abs(deviation_seed) > 1:
#                         deviation_seed = np.random.normal(scale=9.0)
#                     delta_delta_x += deviation_degree * (math.pi / 180) * deviation_seed
#                     delta_delta_y += deviation_degree * (math.pi / 180) * deviation_seed
#                 gravity_x, gravity_y = self.generate_delta_function(source_point_x, source_point_y, target_point_x,
#                                                                     target_point_y)
#                 last_source_point_x, last_source_point_y = source_point_x, source_point_y
#                 delta_path_x = (delta_x(delta_delta_x, max(delta_speed, 1 / 200))) * 1 / math.log(steps + 2)
#                 delta_path_y = (delta_y(delta_delta_y, max(delta_speed, 1 / 200))) * 1 / math.log(steps + 2)
#
#                 # d = (2 - 1 / n)
#
#                 source_point_x += delta_path_x
#                 source_point_y += delta_path_y
#                 delta_delta_x *= (1 - delta_delta_decay)
#                 delta_delta_y *= (1 - delta_delta_decay)
#                 target_source_dist = dist(source_point_x, source_point_y, target_point_x, target_point_y)
#                 delta_gravity_x = (gravity_x(0, max(delta_speed, 1 / 200)) / (target_source_dist))
#                 delta_gravity_y = (gravity_y(0, max(delta_speed, 1 / 200)) / (target_source_dist))
#                 # delta_gravity_x = (gravity_x(0, max(delta_speed, 1/200)) * (math.log(steps + 2)))
#                 # delta_gravity_y = (gravity_y(0, max(delta_speed, 1/200)) * (math.log(steps + 2)))
#
#                 source_point_x += delta_gravity_x
#                 source_point_y += delta_gravity_y
#                 target_source_dist = dist(source_point_x, source_point_y, target_point_x, target_point_y)
#                 # print(source_point_x, ',',source_point_y)
#                 curr_delta_x = delta_path_x + delta_gravity_x
#                 curr_delta_y = delta_path_y + delta_gravity_y
#                 x_below_threshold = abs(curr_delta_x + acc_delta_x) < delta_x_threshold
#                 y_below_threshold = abs(curr_delta_y + acc_delta_y) < delta_y_threshold
#                 if x_below_threshold and y_below_threshold:
#                     acc_delta_x += curr_delta_x
#                     acc_delta_y += curr_delta_y
#                 elif x_below_threshold:
#                     acc_delta_x += curr_delta_x
#                     pathlist_x.append(checkpoint_x)
#                     pathlist_y.append(checkpoint_y + curr_delta_y + acc_delta_y)
#                     deltalist_y.append(abs(curr_delta_y + acc_delta_y))
#                     deltalist_x.append(0)
#                     acc_delta_y = 0
#                     checkpoint_y = source_point_y
#                 elif y_below_threshold:
#                     pathlist_x.append(checkpoint_x + curr_delta_x + acc_delta_x)
#                     acc_delta_x = 0
#                     checkpoint_x = source_point_x
#                     acc_delta_y += curr_delta_y
#                     pathlist_y.append(checkpoint_y)
#                     deltalist_x.append(abs(curr_delta_x + acc_delta_x))
#                     deltalist_y.append(0)
#                 else:
#                     pathlist_x.append(checkpoint_x + curr_delta_x + acc_delta_x)
#                     pathlist_y.append(checkpoint_y + curr_delta_y + acc_delta_y)
#                     acc_delta_x = 0
#                     acc_delta_y = 0
#                     checkpoint_x = source_point_x
#                     checkpoint_y = source_point_y
#                     deltalist_y.append(abs(curr_delta_y + acc_delta_y))
#                     deltalist_x.append(abs(curr_delta_x + acc_delta_x))
#
#                 pointlist_x.append(source_point_x)
#                 pointlist_y.append(source_point_y)
#                 # log_file.write('\t' + str([delta_delta_x, delta_delta_y]) + ' ' + str([delta_x(delta_delta_x,1/n_steps), delta_y(delta_delta_y,1/n_steps)]) +'\n')
#                 # print(steps, [source_point_x, source_point_y], [delta_delta_x, delta_delta_y], [gravity_x(0, 1/n_steps), 1 / target_source_dist])
#                 # log_file.write('\t' + str(steps) + ': ' + str([source_point_x, source_point_y]) + ',' + str([delta_delta_x, delta_delta_y]) + ',' + str([gravity_x(0, 1/n_steps), 1 / target_source_dist]) + '\n')
#                 steps += 1
#             print(deltalist_x)
#             if plot:
#                 if one_plot:
#                     ax.plot(pathlist_x, pathlist_y)
#                     ax.plot(target_point_x, target_point_y, "or")
#                 else:
#                     ax[sim_row_index][sim_col_index].plot(pathlist_x, pathlist_y)
#                     ax[sim_row_index][sim_col_index].plot(target_point_x, target_point_y, "or")
#                 print(steps)
#
#             # print(deltalist_x, deltalist_y)
#             # print(pointlist_x, pointlist_y)
#             # deltalist_x = avd_discretize(deltalist_x, 32767, 121.5, True)
#             deltalists[sim_row_index][sim_col_index].append({
#                 "deltalist_x": deltalist_x,
#                 "deltalist_y": deltalist_y
#             })
#     if plot:
#         plt.savefig('./figs/' + plot_title + '.png')
#         plt.close()
#     for row_index, deltalist_row in enumerate(deltalists):
#         for col_index, deltalist_col in enumerate(deltalist_row):
#             deltalist_col = deltalist_col[0]
#             if plot:
#                 plt.plot(deltalist_col['deltalist_x'])
#                 plt.savefig('./figs/' + plot_title + '-' + str(row_index) + '-' + str(col_index) + 'deltalist_x.png')
#                 plt.close()
#                 plt.plot(deltalist_col['deltalist_y'])
#                 plt.savefig('./figs/' + plot_title + '-' + str(row_index) + '-' + str(col_index) + 'deltalist_y.png')
#                 plt.close()
#     # plt.plot(pathlist_x, pathlist_y)
#     # plt.show()
#     # plt.plot(deltalist_x, deltalist_y)
#     # plt.show()
#     # exit(0)
#     return deltalist_x, deltalist_y


# for deviation_degree_index in range(40, 65, 5): #8
#     deviation_degree = deviation_degree_index
#     for deviation_chance_index in range(3, 8): #6
#         deviation_chance = deviation_chance_index / 10
#         simulate_path(deviation_degree, deviation_chance, 4)
