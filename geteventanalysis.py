# -*- coding: utf-8 -*-
"""getEventAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1frElZGXAE2zQ-mF3Rki8KPoazn50BPTO
"""

import pandas as pd

# input_data_lines = list(map(lambda data: data.split(' '), '''string'''.split('\n')))

with open('data/anubis_collecting_mines_activating_skills_hitting_monsters/getevent.txt', 'r') as getevent_file:
    input_data_lines = list(map(lambda data: data.split(' '), getevent_file.read().split('\n')))

touch_counter = 0
input_events = {}
last_line = ['', '', '']
input_events_list = []
for line in input_data_lines:
    if touch_counter in input_events:
        input_events[touch_counter].append(line)
        input_events_list.append([touch_counter] + line)
        if last_line[-1] == 'ffffffff' and last_line[-2] == '0039':
            touch_counter += 1
        last_line = line

    else:
        input_events[touch_counter] = [line]
        input_events_list.append([touch_counter] + line)
        last_line = line

df = pd.DataFrame.from_dict(input_events_list)
df

df = df.drop([1, 2, 3], axis=1)

df_col_names = ['event_index', 'event_timestamp', 'input_device', 'event_type', 'event_code', 'event_value']
df = df.rename(mapper={df.columns[col_index]: df_col_names[col_index] for col_index in range(len(df_col_names))},
               axis=1)
df.dropna(inplace=True)

df['event_timestamp'] = df['event_timestamp'].map(lambda event_timestamp: event_timestamp[:-1])

df.to_csv('unmapped_vals.csv')

df['event_value'] = df['event_value'].map(lambda event_value: int(event_value, 16))

event_codes = list(map(lambda event_code: int(event_code, 16), ['0039',
                                                                '0030',
                                                                '003a',
                                                                '0035',
                                                                '0036',
                                                                '0000',
                                                                '003a',
                                                                '0039',
                                                                '0000']))

event_type_mapping = {
    0: 'EV_SYN',
    1: 'EV_KEY',
    3: 'EV_ABS'
}
df['event_type'] = df['event_type'].map(lambda event_type: event_type_mapping[int(event_type)])

event_code_mapping = {
    57: 'ABS_MT_TRACKING_ID',
    48: 'ABS_MT_TOUCH_MAJOR',
    58: 'ABS_MT_PRESSURE',
    53: 'ABS_MT_POSITION_X',
    54: 'ABS_MT_POSITION_Y',
    0: 'SYN_REPORT',
}

key_mapping = {
    102: 'KEY_HOME',
    580: 'KEY_APPSELECT',
    159: 'KEY_BACK',
    116: 'KEY_POWER'
}
raw_key_mapping = {"0002": "KEY_1",
                   "0003": "KEY_2",
                   "0004": "KEY_3",
                   "0005": "KEY_4",
                   "0006": "KEY_5",
                   "0007": "KEY_6",
                   "0008": "KEY_7",
                   "0009": "KEY_8",
                   "000a": "KEY_9",
                   "000b": "KEY_0",
                   "000c": "KEY_MINUS",
                   "000d": "KEY_EQUAL",
                   "000e": "KEY_BACKSPACE",
                   "000f": "KEY_TAB",
                   "0010": "KEY_Q",
                   "0011": "KEY_W",
                   "0012": "KEY_E",
                   "0013": "KEY_R",
                   "0014": "KEY_T",
                   "0015": "KEY_Y",
                   "0016": "KEY_U",
                   "0017": "KEY_I",
                   "0018": "KEY_O",
                   "0019": "KEY_P",
                   "001a": "KEY_LEFTBRACE",
                   "001b": "KEY_RIGHTBRACE",
                   "002b": "KEY_BACKSLASH",
                   "001e": "KEY_A",
                   "001f": "KEY_S",
                   "0020": "KEY_D",
                   "0021": "KEY_F",
                   "0022": "KEY_G",
                   "0023": "KEY_H",
                   "0024": "KEY_J",
                   "0025": "KEY_K",
                   "002a": "KEY_LEFTSHIFT",
                   "0026": "KEY_L",
                   "0027": "KEY_SEMICOLON",
                   "0028": "KEY_APOSTROPHE",
                   "001c": "KEY_ENTER",
                   "002c": "KEY_Z",
                   "002d": "KEY_X",
                   "002e": "KEY_C",
                   "002f": "KEY_V",
                   "0030": "KEY_B",
                   "0031": "KEY_N",
                   "0032": "KEY_M",
                   "0033": "KEY_COMMA",
                   "0034": "KEY_DOT",
                   "0035": "KEY_SLASH",
                   "0039": "KEY_SPACE",
                   "0069": "KEY_LEFT",
                   "0067": "KEY_UP",
                   "006c": "KEY_DOWN",
                   "006a": "KEY_RIGHT"}
raw_key_mapping = {int(key, 16): value for key, value in raw_key_mapping.items()}
key_mapping.update(raw_key_mapping)

df['event_code'] = df['event_code'].map(lambda event_code: int(event_code, 16))


def map_event_code(row):
    # print(row['event_code'], end='-')
    # print(row['event_type'], end='-')
    if row['event_type'] == 'EV_KEY':
        # print(key_mapping[row['event_code']], end='-')
        row['event_code'] = key_mapping[row['event_code']]
    else:
        # print(event_code_mapping[row['event_code']])
        row['event_code'] = event_code_mapping[row['event_code']]
    return row


df[['event_type', 'event_code']] = df[['event_type', 'event_code']].apply(map_event_code, axis=1)

df

df[df['event_code'] == 'ABS_MT_POSITION_Y']['event_value'].describe()

import numpy as np

df['event_timestamp'] = df['event_timestamp'].astype(np.float64)

first_timestamp = df['event_timestamp'].iloc[0]
df['event_timestamp'] -= first_timestamp

df

df.to_csv('touch_data.csv')

df = pd.read_csv('touch_data.csv')
df.drop(df.columns[0], axis=1, inplace=True)
df

events = []
event_index = -1
x_event = False
y_event = False
last_x = None
last_y = None
for index, row in df.iterrows():

    if row['event_code'] == 'ABS_MT_TRACKING_ID':
        if row['event_value'] == 0:
            event_index += 1
            events.append({
                'event_index': row['event_index'],
                'event_sequence': [],
                'event_x_dists': [],
                'event_y_dists': []
            })
            last_x = None
            last_y = None
        elif row['event_value'] == 4294967295:
            pass


    elif row['event_code'] == 'ABS_MT_POSITION_X':
        x_event = True
        if last_x is None:
            last_x = row['event_value']
        else:
            events[event_index]['event_x_dists'].append(abs(last_x - row['event_value']))
            last_x = row['event_value']
    elif row['event_code'] == 'ABS_MT_POSITION_Y':
        y_event = True
        if last_y is None:
            last_y = row['event_value']
        else:
            events[event_index]['event_y_dists'].append(abs(last_y - row['event_value']))
            last_y = row['event_value']
    elif row['event_code'] == 'SYN_REPORT' and row['event_value'] == 0:
        event_str = 'x' if x_event else ''
        event_str += 'y' if y_event else ''
        if event_str != '':
            events[event_index]['event_sequence'].append(event_str)
            event_str = ''
        x_event = False
        y_event = False
        event_sequence_index = len(events[event_index]['event_sequence'])
        if len(events[event_index]['event_x_dists']) < event_sequence_index:
            events[event_index]['event_x_dists'].append(0)
        if len(events[event_index]['event_y_dists']) < event_sequence_index:
            events[event_index]['event_y_dists'].append(0)
    # if len(events) > event_index and events[event_index]['event_index'] == 796:
    #     print(row)
    #     pass
# events

events

long_events = list(filter(lambda event: len(event['event_sequence']) <= 11, events))

long_event_xs = {}
long_event_ys = {}
for event in long_events:
    for x_dist in event['event_x_dists']:
        if x_dist in long_event_xs:
            long_event_xs[x_dist] += 1
        else:
            long_event_xs[x_dist] = 1
    for y_dist in event['event_y_dists']:
        if y_dist in long_event_ys:
            long_event_ys[y_dist] += 1
        else:
            long_event_ys[y_dist] = 1

long_event_xs

long_events

import matplotlib.pyplot as plt

fast_click_events = list(
    filter(lambda event: len(event['event_sequence']) < 11 and len(event['event_sequence']) > 0, events))

one_events = list(filter(lambda event: len(event['event_sequence']) == 1, fast_click_events))
n_events = len(one_events)
print(n_events)
print(one_events.count(['xy']) / n_events)
print(one_events.count(['x']) / n_events)
print(one_events.count(['y']) / n_events)

greater_than_one_events = list(filter(lambda event: len(event['event_sequence']) > 1, fast_click_events))
n_greater_than_one = len(greater_than_one_events)

list(filter(lambda event: event['event_sequence'][0] == 'xy' and event['event_sequence'][-1] == 'xy',
            greater_than_one_events))
list(filter(lambda event: event['event_sequence'][0] == 'xy' and event['event_sequence'][-1] != 'xy',
            greater_than_one_events))


def create_all_same(same_char):
    def filter_all_same(event):
        tail_events = event[1:]
        return tail_events.count(same_char) == len(tail_events)

    return filter_all_same


print(len(list(filter(create_all_same('x'), map(lambda event: event['event_sequence'], greater_than_one_events)))))
print(len(list(filter(create_all_same('x'),
                      map(lambda event: event['event_sequence'], greater_than_one_events)))) / n_greater_than_one)
print(len(list(filter(create_all_same('y'), map(lambda event: event['event_sequence'], greater_than_one_events)))))
print(len(list(filter(create_all_same('y'),
                      map(lambda event: event['event_sequence'], greater_than_one_events)))) / n_greater_than_one)

def filter_not_all_same(event):
    return not create_all_same('x')(event['event_sequence']) and not create_all_same('y')(
        event['event_sequence']) and not create_all_same('x')(event['event_sequence'][:-1]) and not create_all_same(
        'y')(event['event_sequence'][:-1])


not_all_same_events = list(filter(filter_not_all_same, greater_than_one_events))
# give the x list, y list a very small chance of ending with xy (1/95 or whatevs)
event_tails = []
event_heads = {
    'x' : 0,
    'xy' : 0,
    'y' : 0
}
for event in not_all_same_events:
    event_tails += event['event_sequence'][1:]
    print(event)
# exclude the long tails
print(event_tails.count('x'))
print(event_tails.count('y'))
print(event_tails.count('xy'))
# print(not_all_same_events)
transition_probabilities = {}
action_to_index = {
    'x': 0,
    'xy': 1,
    'y': 2
}
index_to_action = {
    0: 'x',
    1: 'xy',
    2: 'y'
}
for event in not_all_same_events:
    last_event_action = None
    event_heads[event['event_sequence'][0]] += 1
    for event_action in event['event_sequence']:

        if last_event_action is not None:
            event_action_pair = (last_event_action, event_action)
            if event_action_pair in transition_probabilities:
                transition_probabilities[event_action_pair] += 1
            else:
                transition_probabilities[event_action_pair] = 1
        last_event_action = event_action
print(transition_probabilities)
transition_matrix = np.zeros((3,3))
for (source,dest),transition_count in transition_probabilities.items():
    transition_matrix[action_to_index[source]][action_to_index[dest]] += transition_count
transition_matrix /= transition_matrix.sum(axis=0)
print(transition_matrix)
n_actions = 5
last_action = np.random.choice(['x', 'xy', 'y'], p=[2/18, 13/18, 3/18])
gen_event_sequence = [last_action]
for event_action_index in range(0, n_actions):
    event_action = np.random.choice(['x', 'xy', 'y'], p=transition_matrix[:,action_to_index[last_action]])
    gen_event_sequence.append(event_action)
    last_action = event_action
print(gen_event_sequence)
exit(0)

xy_dict = {}
tracking_timestamp = None
# last_timestamp = None
for index, row in df.iterrows():
    if row['event_timestamp'] not in xy_dict:
        xy_dict[row['event_timestamp']] = {'timestamp': row['event_timestamp']}
        # if last_timestamp is not None:
        #     xy_dict[row['event_timestamp']]['event_elapsed'] = row['event_timestamp'] - last_timestamp
        # else:
        #     last_timestamp = row['event_timestamp']
    if row['event_code'] == 'ABS_MT_POSITION_X':
        if tracking_timestamp is None:
            tracking_timestamp = row['event_timestamp']
        if 'event_index' not in xy_dict[row['event_timestamp']]:
            xy_dict[row['event_timestamp']]['event_index'] = row['event_index']
        xy_dict[row['event_timestamp']]['x_val'] = row['event_value']
    elif row['event_code'] == 'ABS_MT_POSITION_Y':
        if tracking_timestamp is None:
            tracking_timestamp = row['event_timestamp']
        if 'event_index' not in xy_dict[row['event_timestamp']]:
            xy_dict[row['event_timestamp']]['event_index'] = row['event_index']
        xy_dict[row['event_timestamp']]['y_val'] = row['event_value']
    elif row['event_code'] == 'ABS_MT_TRACKING_ID' and row['event_value'] == 4294967295:
        if tracking_timestamp is not None:
            xy_dict[tracking_timestamp]['release'] = row['event_timestamp']
            xy_dict[tracking_timestamp]['elapsed'] = row['event_timestamp'] - tracking_timestamp
        tracking_timestamp = None

timestamp_df = pd.DataFrame.from_dict(xy_dict).T
timestamp_df = timestamp_df.set_index('timestamp')
timestamp_df = timestamp_df.dropna(how='all')
timestamp_df['event_index'] = timestamp_df['event_index'].astype(int)

import matplotlib.pyplot as plt
import math

last_timestamp = None


def add_timestamps(row):
    global last_timestamp

    if last_timestamp is not None:
        row['timestamp_elapsed'] = row.name - last_timestamp
        last_timestamp = row.name
    else:
        last_timestamp = row.name
    return row


timestamp_df = timestamp_df.apply(add_timestamps, axis=1)
timestamp_df

timestamp_df['event_index'] = timestamp_df['event_index'].astype(int)

for group_index, groupby_df in timestamp_df.groupby('event_index'):
    print(groupby_df)


def fill_coords_calc_dist(row):
    global last_x
    global last_y
    global last_pos
    if not pd.isna(row['x_val']):
        last_x = row['x_val']
    else:
        row['x_val'] = last_x
    if not pd.isna(row['y_val']):
        last_y = row['y_val']
    else:
        row['y_val'] = last_y
    if last_pos is not None:
        row['dist_traveled'] = math.sqrt((row['y_val'] - last_pos[1]) ** 2 + (row['x_val'] - last_pos[0]) ** 2)
        row['mouse_velocity'] = row['dist_traveled'] / row['timestamp_elapsed']
        last_pos = (row['x_val'], row['y_val'])
    else:
        last_pos = (row['x_val'], row['y_val'])
    return row


first_points_x = []
first_points_y = []
counter = 0
timestamp_df['event_index'] = timestamp_df['event_index'].astype(int)
n_points_data = []
for group_index, groupby_df in timestamp_df.groupby('event_index'):
    # break
    # print(groupby_df.shape[0])
    if groupby_df.shape[0] == 1:
        continue
    else:
        if groupby_df.shape[0] < 11 and groupby_df.shape[0] > 1:
            if counter == -1:
                counter += 1
                continue
            else:
                print(groupby_df.shape[0])
                n_points_data.append(groupby_df.shape[0])
                # print('x_val: ', (groupby_df.shape[0] - groupby_df['x_val'][groupby_df['x_val'].isna()].shape[0]) / groupby_df.shape[0])
                # print('y_val: ', (groupby_df.shape[0] - groupby_df['y_val'][groupby_df['y_val'].isna()].shape[0]) / groupby_df.shape[0])
                # print(groupby_df)
                last_x = None
                last_y = None
                last_pos = None

                groupby_df = groupby_df.apply(fill_coords_calc_dist, axis=1)

                # first_row = groupby_df.loc[groupby_df.index[0]]
                # ax = groupby_df.plot(x='x_val',y='y_val')
                # ax.plot(first_row['x_val'],first_row['y_val'], "or")
                # first_points_x.append(first_row['x_val'])
                # first_points_y.append(first_row['y_val'])
                # ax.set_title(first_row.name)
                # ax = groupby_df.plot(y='dist_traveled')
                # ax = groupby_df.plot(y='mouse_velocity')
                print(groupby_df[['dist_traveled', 'x_val', 'y_val']])
                # groupby_df[['mouse_velocity','dist_traveled','x_val','y_val']].to_csv('extract.csv')
                counter += 1
                # print(groupby_df.shape[0])
                # break
# print(counter)
# # plt.plot(x=first_points_x, y=first_points_y)
# # plt.show()
# plt.hist(n_points_data, bins=40)
# plt.show()

# print(sum(n_points_data) / len(n_points_data))

'''fast click data mean rows: 1.353 geometric distribution --> p = 0.739'''

'''medium click data mean : 80.9024 uniform dist between 40 to 130'''

'''long click data mean : 194 unfirom dist between 140 to 300+'''

for event in long_events:
    event_xs = {}
    event_ys = {}
    for x_dist in event['event_x_dists']:
        if x_dist in event_xs:
            event_xs[x_dist] += 1
        else:
            event_xs[x_dist] = 1
    for y_dist in event['event_y_dists']:
        if y_dist in event_ys:
            event_ys[y_dist] += 1
        else:
            event_ys[y_dist] = 1
    plt.scatter(x=range(len(event['event_x_dists'])), y=event['event_x_dists'])
    plt.title(str(event['event_index']) + '-xdists')
    plt.show()
    plt.plot(list(filter(lambda event: event is not None, event['event_x_dists'])))
    plt.title(str(event['event_index']) + '-xdists-line')
    plt.show()
    print('xdists', event_xs)
    plt.scatter(x=range(len(event['event_y_dists'])), y=event['event_y_dists'])
    plt.title(str(event['event_index']) + '-ydists')
    plt.show()
    plt.plot(list(filter(lambda event: event is not None, event['event_y_dists'])))
    plt.title(str(event['event_index']) + '-ydists-line')
    plt.show()
    print('ydists', event_ys)
    event_df = timestamp_df[timestamp_df['event_index'] == event['event_index']].apply(fill_coords_calc_dist, axis=1)
    event_df.plot(x='x_val', y='y_val')
    plt.show()

groupby_df

timestamp_df[timestamp_df['elapsed'] > 0.16]

''' mean vals
x_val      15279.148148
y_val      17854.765432
release      136.941063
elapsed        0.091872 std 0.015145
dtype: float64
'''
'''
1 in 40 chance:

uniform dist mean 1.2, min 0.8, max 1.6

'''

df[((df['event_timestamp'] > 268.23) & (df['event_timestamp'] < 270))]